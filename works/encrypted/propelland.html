<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc86c7d1a52150680a761e70bcae69e61424a74a071830177e5285d77437faa054ce48df4331ae1240bfa5163fe6fd63c28df48afb9385af6b051c41ab423483701fa81bc82b86a3be6197e275aace2502a0509b33b6bf13c7caed2f938fc5e0b863c6f9c4ef1e5c8e38351c1154fb71aa8610032cedfc2b8c6365d3b123bf5730827b8c7a17a70bc75db4dff6f5839e3730bdf2acd26a6f895df258c62c13755f89cba91e746e67f0eaacdcec24aa4f3434d0be7297aca4de232131bf95bf9bae87f4e81792d77b6ab6c476ea06226c0cb3047270346935b4b0d4f1b7fd00f81872dda35ad288b88c2f0ce2cf025680bfa8582f318291f8cf518d4f285f8b61de4ec2911a74fcb5e4a14894fcaabdb9c40eb5b6dd3eee0d87eb095405ab9deb12705e681586a3fb347dcbd5c5e17a0fbd7513f9db7a63cf928933137aba3999d4cada1fb999797a4df014f6f58447e8957a252866c88f68f610507e4f5e69261e5e5fd2d31d824b04ee128d397f98d45c3e829525fca026a62e20e4b987063f46a7486ff6c657df9c560c284b12c561065097f1e767ba02c78dd1a4344ae0aa4df344e2676ae634a4aa9a12258e0e03a0e4c8b2a8ff2d03894e373db11920bf7fe39b0afefccb52ee63174bbda9d7b675b7e99953d7ba1bef8ac9c8d0f2f38b7e4e29b99a61953582309e695d306cb1a4bcf37426afd6759fbf2ad236be1e8b8014ff5b3694dca444dde14e87c80baa98f3c9d11c84aaf5bfaff2031aa492150047947d59d1066feaf906e9c8fbfd15293e09362760fbecbf9be342fd3d13bbe4188cc8dfb52f26c1408962362c905559de60f8a45cb838d365af0b39ac0bd55905ecd7877a966f96b3867ab014add2a44f32dc193d21ffc4071854d5fd4e81309ee1b692c5c02dcab18afc1c6c8b54a47caed2f4a3d1d401c7dd25d77178a93e6f3c77eebffb7499870dc6d7d130ca86900522c0096cd00b947d053d26df8f22648f429bcc1465993ee5c28a8cb00c9e42eb28aa69cacede9212c2824a7d39716b8e8252a751c784bb28485153d90e1afdb4b2144c9b8550fe8c3cc872aa6c85bd69082a04016795f4f1a7257657faea3242355330402daff254a4353fae7f084e27ad87708b7fb480ed59a88c50fb0169a203e3de376f0bb1e0e923c047f6d42b0194cb08f6d2aa88868d2f718dc8a51b3ffcb6a689e6bae2c5e68dbf1f707ba471e04438549b0a87b4bbadf60d611a8f23f2391e33b46c5a24b8d1eda2aa242fba0f7f7b877fb1323168eeba7f0f7cd4047f6f69ebb6c47834f76a98bf4e12c66567f77bbdc170d301a74c412c49d91843833bcef4bc1d9acfd934e3fdfa208278a3e0e0c77f3f49606148dfcf36cf736f0e381acea36e16630a9000c4544cea2476492af9a4ad127c1b3ce9a5e39ffc95ccaf316f605eba09b5a054926580ada808ad198675b2eaac87986b7db2332a3b7769e81c1a166fc44d30486e523b07d2e5bc33c26cd6f7535c789d630d19c671024f2f413b72312186462be95d0151df5d12d58f8e33faed705eeae25011eacdced3aed51ad3e71e40669e993708761afe11311f109804fd8baa4fc9cbc568340f798d496d0902d5b36b50cca8d1615348850c2c7b49d7187010262a7e677f31ce3a436a805588db8ae5a176a1677aff8de117021fc76113e95ce7c3fb41ecad53a5382a3b0119ac55586e966a6f770bb48f476d7b429b50b1fdbb793eeac8845af495395d51e501db037b8eeaef014404f3148a2349055da35b148efee34a4ef3778149def03234a2c77fc29be2f0c9783b9239240af99065111e665cff27f391bda465529042680fbabd21002138412aaf590e31bcd2fdbe723046bf5d75ab8ba35e3749ef821d1ab4547d8f1669fad894c244c0d4eb8653a3a397d1ad250f3f727e8e8492207bd1e678aeed6d81c68d215fd9a40563b6700853eee3ace445d3fbd33873e9009180e4533875abc4a9d989947446e5519e3cb0ecd786459ed24ff4ce520042ec23f7202f60386cce4699d3c1433454fb4015885e3eb81a2f2e19777197461eb17a4dd60c05cf83252e9f277cc536cb01068323d12490e3e8d762b844df1985b5748ad25089354223c28f6ef2566f40bd7fed90826fe8a190b3ebb2acc6d98d4260180640c0f58fa1b0845022f56b83bd8a0da20874d3bd0b0a52963ea230855cfe1a7f431dc498c37fef25414a9265656f370fb6c68f5720dae29ef6f804d27c310b4233e27f1db23283be2ca4ed7ed2d3ff4a21b1931aa6ae9636bbfa3ae345e74bde3673f3bae5b7cbf63cd93bda1000b68ac6ea5f9159bd60c11ab8cb0e9c23fecd75004d3916892bb01b28f17b0a8cac7f1648d451d1c9397522dba867d5d10f380b0ca935ed6c74bc38ffa15bfcd95cb5f993b139be3629a2eb3ed1db2b95a56b8ffe04fe155ddffd5e86ac0073f042dd3e848c040ea6ecd7e5bd4db04317f3e44ed631658219089e12aef5493ba6c33a600ba418ddf0576671b1b32efad89d440ace3c44703a17cb61efdcdafe4c9ca2b6cd5ffb2c41aa8a4dcb54ad9348bd680d9fb8044608d777592b95fdf159f67d6096f8fc69667d202a8c12302ca26849d725cc07a790a5b8e13c04cf946ac42ee0ad630d4ca0c5f3bab46eb383375a72200d10d9047900c84f1f274660746dd33f0cc83a996ab3d861c33f3ec58ea31e22dddabee25fdecacbc0450ca4ed763a5a24cae77bf0c8171a1f74f24ac4eae26361c53e3337ccb87c5efaa7bccc6f44d88514fe4fbcdb388761bff2efb7d746182eb241249048dd9f400a60c3a79fc3f69fb5c5040280ba6d2c7e4373f9e896c9c24888b7092d34da7f8e3b3253a6da6a748bc361af8d41ce6a858a36e85562978e64e92acb9a8f3beecea26e9a3e67c13c60ed4ffeccfcc752c0e059da48d455ff0b474ab797cc023691c594c2a27ad1ad1ca1a9ae1d4d1ea8d920404602e2c833248a437965b0bc8178374de1725758dfd4d090cb47b524593b39fdd6d4a0becd98cdf429ceaab3b3be9e98b764daeb9787fed320019823b15f699c466c90e5e7a58ffcd109962bd3d2d54ba7816ce6d73abbadfc0622811b9eaf822c545b0c4dd220e5861195a3b7f201048b39c009504ea4040ba7ba7b4ff21e0ae80e7eeb9b8e94d6fe00928b18a6122b2b42dbc78608740261bdafa298eb1d790d1a21b07c00981f57a740fd62263ca560b4cbf6cf6681d00c1b8c0d9d383ca47b451baf91d7c5c2c5426da599b2dd150ee817bdef3dc69d483c02198e54bc570cfcf087557abbec892638007b77b1880d594ef36459a8a8404b20f93e33ed812d9089732d764f0ee7bf349164e340da2aa62e3dce4a912943e61744c0aaccdf388afe76c87ba8f1cecb7b9a18ffa8645907029cd7cfcd2f300f73c670e28b44b4bfe7b53644946f2bfffd0c456b8ce7c46f537fbe7ce73e61009ac294a49ccf467764841c081c0af251643b0f15448fab69ed745953109fc9bc12255c041aba883b0377ff242d0056f2bd3f7f08c98677b1f6dd707f24250b9d07fd53dcd5e0d39ef8a1eba57cfeb38c8c115a95681f6e2c5cefbeab40b05777205bbfff6d3f047b4ca4a196e64237b35ed3305948bec02c8bde0f43ed961e11bc9c0a651625cc778dc5e67e5897ef6d3decaf35b63551f61a337814720ce4de9185334b8c6c39528c15b7fa77de7e0b736c62ac9d79a17aed6fd6422b62a50d86880f62f608ec0425b6769e2e7c1cbaf17d7ae337bb4537d0641b5a245e297f591ab478a9ed245ab1a083f68d3c3a40757c833a92ef80ba3a281fe0ca948875348267e9bd6080141f1a02b380d0758132ac796d8d0f03de9d40afa8e81998107ce3a583791ebd7f6dcb39df7c56cfed367deaf23c6aa3590fcf33037b6dc9098a287b7048c4ce587a155ca6410334622827e20aa808b3c7c54f47227d42bacfe3f2bbb773ece3b277124367e9837165bd41e59fb92f9c2139b9625f4d663b1b1f158830e9ce35b02123ed768d5286c787987606e95d806e26f0279339066dd0fbc44431ce1fa04d9110ffae53de69d048b65d8e204ff5e2ae5994e668adbb4af3ca2b2d5ca3369db45492ce9d13ece67d8ddeec14e1af5a0baa59a1348d9ec22a17f6a6e56098df2b98c845605ea293b5c2b5cc82ecb588db976fc8cef5ef7b4c4b1541cccef48a85366ecfe6983a1d2252fc94b407439072f362224e4e4d81de22ebbcce32f9376fbdd5f44f8648f1736044cf61d8a36768a35d916b35872a9922e9bb08e84457f7e8bcafe75c80982a7dbc16e0983a7738f14bd9ab174ed5199c9f2fd65d4518e3d3ab8ca71730f04db9d6a5cfa365dad613ffdb664a3d4290dbe5c2bfd2c71fd87e91f96623b675a90933b2e964d50ba5d5de518bc2eaf045c51bbea2422b59e2280cc9bcf446ce4ceeb9761707e1c86b77e5d00b187780e8835565d8365d9559a9579e16c2784fd7a7ff4e5cd7e36b0f37fded4a8a034a04e297b3de97aa548bcfdcb7203a1ee6ad306eb7167e99825076dbced2d8f937a810920243215bd4d39619fad824a9123bdba8c8d2b911e85b41dffe808f856b71381064ed69aa10603c51d37e6c275686a485a2a112ab57d573264406a53f5e47dfdc315a9e91e3026504e0761dd55b68b4ee574e7b3e671d02ac349e1d71edb851359f8acb3aa8693864ca94b3fa0bdb868d8f02940db57cff6b0e8edaef96d5099b41f65099f5bdae20f28ea077b582059e83f7f640b0aca934f11cd2dcfda6a984d8c5479897d2c30e9e80c3a9bdbb3fabc0544dfc478f21c226d9520e33c0b5deddc428a71321f0021580d679313b32fac7d911390b9135683b7926bdc7b101800b7318ae3791c670e29bede0179e23a84892f851388e93147381c97d7974a37185f473a324285b1a6233f71cd27c2fe55844c2d4a8c16ad57d77c3cafffbf8aab18ae4bdce27367722be78bf9622e4daa14e6c10b599ed2ca6c3f2641501b3fd36405294454c04f442f385cbffa7719b8cba081b4bdc26bc425de6226a28b7802d617da9dba57d0f1bad893ed74b117263d1fd27570c225d4dbf9bcbd3484a929e5439d2b4858cab87391275c16f7d27fd16a89182ffb708f9e6b6ec7ce5247d6576ade0125a23b7261cf03b27f71e84ece6247780506c2cf04ccbe0b6d5a7a699213021982996a6efb9f454e910d067698d7be6fbecc6d10594a1f7b6fc8e33f126ff2947a1ac2d9adb110b87251e5172461259739ab4f7e0d002910324e7adc0b989f2a6b9d739350cc2972d5f7a018683f3465f7fba74f2814e5b5348c921f4537ae84ad00e1e2b3d89b92873a31daf387bfa65944f2b8ec0286245664ed0281acaf36fd11963da92bd89f37af6baf1d2862e985c2dc53f5bf882ccc5dcf5f13fbfe1cfbccda69c525fb109fc265426fc9fb0c42a335a2b34d5f4020b535b2a2c325500d61bf6e314b52082f46a6f703380e11d182b817b4a8e9d72f27e832e99389379854cb740be76b9bae868581aadea7f1f28d4db75141a29cd260767e6ab9fcbd7466126bb02971599f8d21db87aa502d4d140bb00a91c231a394097f9279b895d4920a84283d0633260e4d1c35baa03e371a201ac062db658ee951fdbac2aa67afdc2f924a419fa52d091eff63fd37b8529dd88b23b562090b500649f257ba40eb2b26d784e83345fa630fdad3b4393c7abc570985a820eb7ace8ab40f27876bb74b0863f76b201b13ffb4b3e005b105de29c6137df90b49134047dc1531b0c3a6d512fc0aa162314cab646acc89cd9be86c49dd8e665baf09124fb356275c3041ac6eaacd7406ef356863bdfa078fcb10ee00560f2dd0abbeeb1f25aa52a977b419f3b7dde2c19f62455f1e98865411027a3708beed3b7c3c0c1121438b6f74e3c93dd55358b533966a05f3bad70534413035609c5faefe84efbd2a910425f70a2b1c1f19e7c7f93fe630c56f60cd5fbf8a8267dfcfe49397c918d8cff1ffc840d5e84d8237418f1a187bc90ff03ca19baad4f406b5d50e7ebb90f5116909b2d394a811c48f067145dd0f54edfb1bf0d7021b0cee71bc2d60fa8b2f90f790ff5f4f97488e2843ceb0f7a9840e4d9701790555416acef89e4395519e08e9d64f3d91c1f37d2d25a70008f23407abcb018d067dda5773ed65dd1b959c6127a3bd93dfc1938dfbf080a0a4447f3df10445b1ecb3cda3c1585237253e808ee1d612bb2ebba65a2d94f80103fd56ef21c12d360110427f4992687a45e979896cab22b609f11ddca2c6d1e2a439a296fd66281e6edece4210b306b70f7246b8f20fd5f1a598dc0bb478ebf7f9943ba85599720828962a3b6cccf65c3d5f14c6038196e4871bdeab008ff8042b7db6e2d4aa7a72f9ef885f23e30aa00e50b59d25307101919d4b2eea567403d5a57ae2c170304c615e5156c31c19a73e34e5f02b61842c9b72823260c0b39cad4d11d9e2c56e1e4a2345ce518e5fcfb08b5946bf45e0d6dc7d8047734f43828e889865e23839135c445d4eecf0f39d6671aecb47fd34bcfebb23fea3ed3467b30075cae752f450d1367ad9676bde5aa0b475549336c3ce2b743c198fda3cbd47a64e2d096e71c93a7101e9b8ad032dee5526aef19f1e1dae6e9c7e5fb5cb163d5753439cd0d4a27cae3ecdb48ca66470e9a897f5195938d000554980825ca3911620136ffe47afed2061cc794639857e493c30e428bd620e5dd9584810ed4dba1e38d11f61d95836c405a47708353522f667a35344db983947ef21fe23d494ef21215f64a704358f5d7474e1c8d2b067a424f459b3027062607c4b66637ce84949b95fd3c24ae9fd1134d3c4c950e9a972158530818031b2e89c234416903c36d6cbbe831f0554a4f4f7d67d17cb75969aa78893095af7f7b0062d903cdb0c02bdea6336f997d17f78d3af06f95f0b32256ecd2031f93e6975aa83dc338fd855509543eaa2beecfb2ffe8802eadc5d247b934f41712c251b31cfb4842397feb616dd48254788f989b6337fac9003258f4c75a3fe3b6076776c5d9b8bf238dc9895e700bb7033ea19acb4fcf795c843cd677206b818bc1a665d4aabfa09ee3077457663fc82d95d9df43c2a296ed47518944f663b1c472043590dd17b46a1ca4552ccecb7a1294136b6887f35113b2658e3d11b47c0e13dadca98a176c0b42bbaad0cf8e609cae6f8b656f067f7f7f9c904161a354312a81b0c0c3b1280068cccefcd24382ae539f512086743e03306317918fda30b09a293636921aac1af95e0f1db38ffa1ab7f3dfdd236d011f22e3d2f79ce6dab27e17ec84c2eb3791fea015fd07b84f58dde9c8938f46d4a9487ce2bb840bf4a380bef663ece9d523bd19b491cb83b97ca13f6abf46b3743adbdce28208d42abfe3fb721a9ba54d2e2a703b0a47000252a47a16cc9137489d43baed7fb73aee279197ef55b83cc8c3b1a83983c622f5e2ec6afbc998bbedac7442d503c115e5cdb126992bb5e6a770974feab48e9f005db2ed91e4fc482df44c864020eaade8427135774b988ef0d8fc817daae7b7b527019e809692afeadacebb0cb642a9b59459f67536a45d14288c53605b358fb9ff1aa045e78d3f61fc13af781f8c413acc9ead09fe5676bed4332ce8d1c8ac7147bc1110bbee296f452629998c69b26d610a0040544531b17ff9d63fa64a10defcf56673bf52ecb6fffb6aa6ef33f281b2e8b87a2a6fed425799af127a8484ced4776e59c66b3a057ab6ec14d3c263ac02d55199c88d52e12c53a719306853c89e31faed2f1e7d55bd42b1bf994f398eaba4084fcde53345b79ff1632578f8c048b5de36772912e8d6c0e12acd6e44dc690ccbf7c3154c002964425de22ad306602770c39d10f466acf2955098b39b067575fc3b91f2908d3cf98c4acfeff0f3721ce7d2b1c81f06b1336148c8041f997e2bdb3957983d5ebd90ab9842e126479cb860df0a51f669428a698f460be0908b7771117dd0d022d39e1509716d5d2f961297163ea0bd5928ed4fc82efdb95c5b12a9dd4d030efad8d2db17140ea9edb31e0d820c2416e630ea26e0ecf176a0b30da5b800a921fd7a2d12987a24b95c4f123627e44fc655e328c70e055fee023a2840d2aaca97ab074bb563731005c079354c3350426828edb26832d76047770bea9b2b75e052ab3869f9f4e0a71517c22ed9ecd3dada780f7655c69aff39ec481644e4477eed6a73dad2b5300e7947edb21fca904c66cce5efe859a26897a0f3a7f41af687f52288438e1084f306fbb66790b749556ffe7e152848304fbbb39392cba0c23d54f7fc02ffa460e45de261e52051b5de9b5d0d0f90ba8e9f8639ae490da44e4b560333c588980c992389a5366218318001647b4b7913d99a13521c19829b9412348b38a7e8422b0dc3de7418afa7afad5838f3385db406362c2def03cda7988399dedca77c19faeb0b9bcfa6da8c66493ed8c3ae18f725f26858a414914dc7db46017b1dfc4fb68e6c8af905b9c8f5aedd5c1591852f7a932eaa63585873380616b7f47bef6a6cc8ffcdefb305830d58bf91103e6a5f68e9305bdbd93b19f85d165c7bf0c0f88cc64d4ca6a15e16a3391d124c3689a3f0b50c20f5ebb3a853755b55afc47c768a92d28aeea84d063ddab184a4b0d7b7a733983162977b51e7e41d301dc24976d7e1e4e1c2e6a634dca04196574061e2eb478ac7a8b3ac6b18dd84edfafe0d9a6ce76bdf7b09e73cf2650ffa5023b916cfbdcaf14f57decc1fb262f84020a99c06ccd89f96538b57ae6f9eec1cf98ff3aed2b0e00c49772e5cf0bca6740da30955bc9fca7af8ce571a09cc0de40b3e89affff123ba0b3e9a3d41a681e55c676bc11c1bc963809f0c565aaa4add6962a00d6b9079e9804281e82f15def82cbbaada239a936fc79781ddf770bd164f387303d70f67278dc457bf589968b4e8106f91b27844a0e4b38107e1a2b3fe208a589fa3f1e6e465bb8d73b3d98d2ed57be8e7f65e02921dd917cccba4839283992a6076d3964d1b939698e435c3c15055d75fb20089254c2d951fc6c874331dbfc99fcf5894ecd60fa3352fbdcea2da01660d82da24b3f4da9b373f1990609a1f741d35ce242ab401d5cb2d7b718c1d1c222531ca2b449ab4dcbf62430e83c91e812181847bcc68f24862dba132b59684d0b0274f9e47c1f2be9badaf88bef3d9a7cb50bc1959f91ae3918ecc7d0efbdcbec83c9601ce388eae69e47ed2d3cc5e35b553cf4f9851014be0cdb43f4cc3d7e6dd59127456fa404cb594d772eb58093d87cff6a1fa03b21131e893d8974081db81712f8c820da8a666f958c53cc003a6e0b6b55be2b63a9382ba9589d0adc710dc603e548b40c3946879d72b804a366aef5c61070e0af760d5d61f62de9f58d8958dae47d80b4a8c0867de968150d0d9b85fbdb34deab300a954f5c5adfaa0c4be8e88974f76dc3abc94499b26c30c11b1b19eaec14f14d9e8eed6db658e14d82a97501a3d91c4e8c558fd707361bc254d3e7e06fe6dee5f7312d1c970643bed30d6018981943e7bb8141610fe9ba1f9d2c89806ce0024aa1866edc19001fe18fd040cc584a4ccd00325e860ffac2f7740e3061977128bab9eec7790c7b69157c0166f9dcfb29a89e3a4f87d64f174bfbfa0e0d2ee7fac2e7c11df5be6b491070ea82d10b60310016e98400379363c52cbf76674268eca2db1e20ed484a7ffda003c26b50c2680f84e9a3cdd56b6ee02701ad2746a7be1fc03281ae0e5fb7fe254bd72ecceff674e7d2fc5b134ad69c2f11b08c40fd84ca7aa807edce95c85a23e519efa929db3114c8f7706c75a7458212caf6c28a0772fa50b2edde9ceb1905b53caf319f36b9655010cc0705bd9cd865d750950e7c6a3c1e9d7bfd7b5c6f5720ab8dfc0f73b3944bf1b22e65b963deb00cd78d8b7ecd2851adb2c33822b0bddb86ece2fb025e5f3df3dc7cff3d58115048a815bb3a07939f31810c41780566ffe657cf0508b4bc0037961c12cbf2c66f47a4bb6cc3b8255db1091cd002b859a3cb3e5f83a97762dcc2013462464f27d7db5a358ce3b144cbe03dbdabdc1aa683871bb6eb4bb28eff00b27a8b1acc906fa8d0849c83a35b22cde6a1bd689ea5552c567a92ebc6d52b6132192dd8fdbe319b7e89ce7e2dc2ce4240296c236ee0d209a5dc151e05f800bfc50a6d91292639e3010e2a6afe7dcd18ddc1bd710afbac28e826585c53da47ac979ee9c792a3d174e44d9b134468980a0b678ff806a8fd94f417236bd4bdf450421a39108cb142c195936c2bc94f5c90bac47627f2b460c1cc87ea4cb16792739f27435ddcec28b47a4267a5d4bc82258120ccf454013921746a3cbe8bff08b21a218ded10f5e8c8bc2d3f942a8099d8487517283ff6b2907448698591a09f534df4f6b362d377a356df940118428f83e3304de9b4df7d3b3539255924a86cd99612d24277fe104835a5cbc8345712199fb5b9d5886ecaf3151e9f23b09b8ad0dfd8f46b7be7896aaf9dbe0092e11e5c9c44ec94778e284242ea0c47fc03a953e06c16376c73d4dccf3fb613dae5fc569028f836e42a52c3d82f2e070e33290e5e0dfe056d157d01af8a02524487ab5fdb782df82f71c4c6b5df67b8a18a1aa8f9b9afbc03081497c9fa3ea18eb6c7739a4b524415bc98cd0ef651524b3348372fedaca00783eb6864abe4d22245b0ceb5e1dc2a11c9c7709b9435d21a2ba6de4c41ef7451fb28edc22f61caf016e9509ac5d43296cd95ab0426047e601f2c6f184fd4854cf577e3137a8941abcefc6ab2f3f1ed9a3f95e0339f0c6bed6b5b5fa77e25da87434b842d6d821822acec0b5d82dec517f51130c4de17476db08d9dea5da12745d87a02cee21de9d24486b44529edb637e82ba4f784e1e403365b39e5c0109c2f519657fa82cc13a6b7f4b93806fab2ec7b940cda198efb1e120f41180302b19e6e4e046daf17c191e085f21c1e598f80e27ab5bd0d90086d9b3c52497ff73fdd58862b1bb8397c53123d25c3be63c2c03e6432bd38fa86a147fd51787d9e159487d6163d5f3a402999d89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f97d0645599a3a8e1f23b09ea48c3ff3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
