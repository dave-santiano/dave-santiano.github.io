<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f57817961ff3750eed0ad464c732cb31bbaead657cfbc093cecb3007d57c8344c4b02a3e3a87777105ca403a9cc1070384067bacd78795b4ffea172e0feee5b08531522d6f8c0920d44646e341af6dc862420e7d81be96a2b136ffb8a5285e91d209f1226f044b40d92f71be58f44d8fd71f617203e0ea5a9d1b0c712bd107fe09180dfacc3d5295a6f8d47e2d13bc27299d6a448123fb37c9999e35ffa2391f6675c2d0900c200d116ddfd375b12ea77d49bc92d3197ec8197b30d643c3e0587c5001db4617df6ff082bad85b20bdf772b5b9199f7df97c2c59a3593bb66de1b61139418274c4a42545b83ca8d855f780400d8e90bac38315b977bfb9c94efa5609830c15f28326f364a101c347ebedd0e2411618844d7a91c89a1eb59d676dfe31254a36389f0b48178943fcad93342a1d314e85c1d6ae2c9d464e9f31f0f3b605d02c99ea31f39813f72197a704e8ea14004050e0a60864b50168271c906812b1becb9fb0554a6281e74e4974458fd2b4cdd2891e56b2df55936fa424ca112423a0bea5bcf1d2272dc48d41e3bff7205251d56826a91d8fce53de3dba01489d4bf378b66c305e81207d632e0dcca43fef8e1bceb5213614d74d44b96217ee1508723708ee1b8cfd769dc0d9b7ebe8aa58a5d62c571aa211ffc456f78b44187e6a42bc1d740b62fc923c7ae974ac45f125c8e05f2eeaf8c1344615812f9bca29e90dab302068bb81d90ff4827071405df8b33334ff263af90701046118fa08c059bf98e024826bfa61eeedd58d2a773e9b93df31f03e9ce7e0cee4000aadff4b2d53efd88e9f6be0decc6b53695153bd1fd408a29898782e636f0bb635ec82984691894f87cbbd3212723363de2473c801c808a3f57170a71ee7ce024b68fd785e74775ccd9786bcd0a2d744a335b927576bd27ce3abedfa1a4e467a3f8ec82f84cb472718131f249ac9d990e7514adda1dcd2e1d8bcf8bd7e042b31299c4e4818f111829908f9849aeded95accbb87d9a88ec3dae94882d5990fb11a364401259743f77503eb753666281413f1a021803a44f0f40cf0f8dd6b3e094eb97bb1c8e6687cb359e7f436efd35257e572b1300f593f4da0259fa5c7d0a90fcc8851dd0829582ab559594b3aa7e0d85b6e5d939fb37251e6769555edbf95e4b8372dabe3e9e712286b46b571e5f70334d1955f59dbdb31fa3d40a4c8b3cbfcb83218224bcb8d0320bb1bea92da07f1061d541904145d6ee75f835e2bab94be88a3dcfbcfebfa08dd3fcccf9500e5183a76d3d5409c6b52c053ba621d2ff80c698a9a0990fd67c33cc0718b8d93da3ec1b8d1917b90ef7cc682c6158bb091aed75f40992f2263c7fb94d977a35f24f68f12f8e0f3ec8b7faa7381c4ad078ba43e6cbb57f59bdb63e3dbf776cf12b60299908208c2f9c266254846e17f7512d5eac23e0f738483969f098dbad0600aeb93515420f6b5a13159356261e216945cbba802385f1a8814d51c44331f271d470df39ee5ef0034ce13e0a7cc1d5760a23626f6fdae9ab48e2cc131ca6b856942569a9a56189a03eed9f64423912f9d25a4d07fa65e83f86737006daeb730a43ce6f31d42579ac9bcd500696a72b550e823881e3cf183c79207505c4a63d33d9cf4b742fddf35714f44f68612b567b14f08275059e63850edf2f7d4402676250632d5cadb76f2193ff8c6fa1a57f2e4f0294effe146905f9e03b7d6be692d1c627839991bba4031063a1fb80f3f1e27f24132a814f1f44ce2b057ca46a90e64bfbb998dbf552fbe36ae0f3cc7c985d4cab26ba5c16314744059c0f8b69e5bce7f74c2584bc05d35e76b092efc86d52ddbb2ae83ae68e9f36c09588c5b6499a71a012708b03aabf3f3adddd250c0c37614e724cf4449d0452ff8b36d59adc88096e80fab52398cd536bd910c8356f28bb5e9dd1198074ea7f4687aef876f07d52c83a36684288b9a27220bc6b69f98041915dd8eb6fb5cd9f6359590f4c585b944109ba2a5d96e5b8729e142a1025b0bbd7f7adc5e573bd8596d584bb8aab7e091aa952146d1865260c476f496e76183c4cf79b75dbeb4353499ddc1f9d3e6eade8c10524af36e52e63336a0624a866fb6416441f768b592a489ebcd817d6f2e776d7cb5581fd16c2287daef639e51805657265ebfcec58cbc64f50b236fc5e331849a0473ef2b7310509bbc87711e4bc1dc94ca02e97bc426668bc10f5a3b1e87a0690a676b5a0622ac0219a796a274bb66e6466a8df042bb76b5cf54a72afa67a2006d60bd711a766d2c60a22e0ce1d6ffcb30f65c2fa3b8faf75002d18c621648221cc018b18a2d1b14aa6e1762c573387f34970010ae0d6a76a415da31563a51d6733be6a8a5856de835b04a3440707a223701587f6d5509c3c7e05089ca57b1fe01eda82e9284effeeb038312503d909a2f3aac57983287d950e3d264b42d2f3da6dbf991675d624cd1a0dfb55b46b72a273127c444b8e3ba0053784de47734e69437d430da8c25d6c589bf929b95ab3e00444097cf790f429b49937b81918499b0cbecd71b589eadb72801819c9dc9a8750872b1ebbb0e50a98206e022decce9f127d42e3932c25aa164065237213f655fad8e65aca1aa980406f36fe0079df246c1cadfe6dc7b4190cd661066e50d57e70ce251ac5c6c6ec0fe627d0870f73b085cad669b3c2c585f68a869aa81fb8e521d402dcee36e962d94ffb1e89282b69129913145fe1b162bcfd11d0228009de3e50ce7309b08e80185e7ae46f0ee05cc181231f2bcbfbb6bcad3e61f8d1302ae47546143b8322c705389c525acb7c5d5c6fb7930d8e31ca0978c3f69365a2c3a7a747f80eae2cabe00cb01a3319db259c34b968216b09055daeb610c7e3bbf5befedd8130b6100562c188af29a4037fa3a75f19c9190803033d6f5aef174d8c942a300ce9cb587dedd821cfcc4f3463d5df029a519fcc99a064c2eb3aad12c9b2a579ecd1075b64f2fad17a020ee862aacfdc3e4898c1399508c844de8bbdd52b84612254ace59dac630ef0a56f9d11b2a4357c90cd6d0d7a9dcf366a0f8daa8d45e229534ce10270156847336e97d8df205f4f9de568c8d090f8b98d7df22040046619770a1061c2a6952abd9a43872ef1883825b240ae956cbbe3110c7b9235b198558346599936a3eade9d60df146c581b878277077364f2ee33a6b749730529e203e45ea5a9276d1a624fc33910c0beb277d4bcfaf3459d19e5f355c8e6b76b2d75d26075d2bd2402d000b7086a1550f2c2fe0a84c067a39fba5dc04f6bccaf51c9c860e9a9f6cddf0fc8c019c495cf2cf805de9e338aaf59dff1c72f1317c4bda098ed3c28810d52c4f8e3f6c6c3622636a288b57ec4c487e1f458e646bedaa48176a1d65523fde2ba1a59498b4d6f27bb5df3ef7d482181f887186a0108d8a38a589d71540c09657c9ae2f4ba7e064f688d59097885d8f795567d0c2e40314e5f88a16535e9176a031d5c26385e071684a97477f305641573349a2cd38ce982be4c0d883569a5e38096743c7a29a80b96431f1872c0fa169d7ca19efdd29407ff9d20012011d4709d1601f7194efc9de6f34c066fd8bafe85c6f29451442e96aac31f791c153e586b075805fef5ac8b0d059b415e8ff737cdcc7106c51af70fd8b6e9946f1c2f9b803520632626c5794d2444307e37dcf863f9dc2bb69654471c46831ca1c303ee1db7698dbf75c33874eb6784df4f07a4c17b95ff366844098a3e62673b94862028c560c10ba797f2d439c67363bdc59b07d25700939ceab239884410d8c94348e9456f62a1fdff9c8ceb7cad002a6a23d436e7883b8a22df4294a06ab81144d7ecdc3afc14f736daf932eec35eb0c1df1befcdd55ca3261827b7d6d501e71fe903f2d671d1d6851de5613146ea8466d501a01e1e0cd2e28ae44baf273b30e2da3d33e2a12003216e2d37f91cc5c7ea6afb4b613993c051cba7dfb83ba33418e9a556a595afeb77c4ab14b4ab6f89d1d236cbb15dc640ac93fde8eee76350a64a1f68b2fbfcdaaa7437a8160d1c817a56506e0eea6ea78bdd3e0854604fb20ea3978ac0cc3832832a7d60729023b76cd91ca0f8c1f39587d36274ee7fa039f4e2c43c7e8b99323a030aab385aaca79d385ab39ac7634a631f9390cf589c31cfc497b70354181a1b1df9d4c6902e816092fc676f2fffa52a27f52165ec3e683d60f0fef0ee240d4d4fa4cf964605fe70824746593cff0b95c29eb60fb034380bbce2b7fadd8e214e14377577ebea3c170b268bb3435a24e15d7e547ac7a8ae0fc742bd79243faea231b6068de2ff09af135a03c24abfc89c6566ee1ab33296fbc1ef6bbfb5dfa0e9ee342e3592b430ab440fa29bd9d0cde77b86109b61a65d77e101fc64142fd3e05a3a616817981535dd9de6db55168094a2c0bcbc3bcf2d1512120375afe41e92812ea90ba220c24fb80cd3577a307b83fb9cfc6359c14f0c730f4cc16a31018be7af94414725c43c1dd23be1b572d2589ab57ec29812e7a830fc45b8ee4defae305812828df41fea61b8da80b388db1b80f982fda095bea5b71b077c542174a148c8a44ad77236fb244ff083b3fd07974771dcbb66b99cd1c9f36eeccbddde14b5f889f0e3db622a63c819deb8b79ae6b0bdb4e1197c3870386f563d1becc0cb999f71147f7f4cef4471ebf5469d015e6c431ff6c6f83539e5f715076ddc7906d920ab038a37c34a8cb2b70778c2c7c0a2d995020bd6a104e3bbb70c95d24eaa8d0e3e402674d30f2883e507f74c6c08c825b706cb1eb267409e6d8f4d01a3e940d7ead2214d6fadf34dff63308c417775bea1a2c4ac3cbff305c8e0ae160fcd124dee125300026cef6c147d31f452b11c0888804dec147b3f3e42ebf4b6e7f8a6c6bd3805c71bdd5d289579d14cd7c81284c923400c3b708d681ab0c55572125920f0e4907e6f19733a8bbf9520c5f31a7f4b6752f973e37d5552b3be29f3109672bdd124662301491b50767016c5b8df613e4ece3aac2be244099c8f4afff5f121a5a7647b87de95572125d3e7f68f65c29bb2d8aa43d654dc982aaeec6871b168e19601a18c3feee4b8b7793e3c35dc2efdda48d0b1d4cc39724feb43ba499fb86a50ed5a42ff332bb32f8c1a9d9bc4af02682e977712d8fea5f899d7a47e396fe7f906b285a3812622972d78033349b801e0fe58aca9706a6789d725d8aba96367956b6743098e9b392e7ed64740aeba5f5946946c49168cba672051ad726ec1ca45d4784db3cddeed4b7b0707aca21c0c04499a2821addba51fd357911172a0b760c4d5c9e702cb910774847d1b12fef13957f4857cc98a00aa99eab072286a036f4dc530e4c86c0c0cadb368d0deecffc785bbab71963756c1263d4b08f1e76a2f3534c661b0587dfc5fcd164543d608fbc0d1d8d083fc89e9a8570c9ebd9d503075a881776f646b2722af503f3428bc665ad5c4626402ccf37f5f761754d45e401dbf63fa86a7577bd249548d2ef4f7c4d7684f930535eb9c901ad3acbe37d2ba59010ab12547603b42809df43aff8f07f474c5f7e1dd3687c75961832cb9b534ea1c64318aab81a7ad590934d39f93a032959333596806b37cd4b0349f838d6b79b177b7c9b25921edbe60a2fa6cf469996d3acd11a4cf3418c1740672ebb363087ebb0c32c7334ab3cbb3c77503b3310bdbdaea75cfcd7bd14fbdb35e9d363f3ebbb86dc43df1baea61c1f2fd7e3a40cd16bc0e56b9ad73f002770518f5b4976ac6aebe11f68f359d490bc125240db6cd0cc53ea85e4f93e4a059bc0eec19be7e4822b74179e88c87d3c67f19d4a3707f2828cc313f1388de6cb171d6d909e28dbf459f9c123969bfca988cbfc2964a76d1acf1d64d6561b65a975e70a4832755060bfbb94abe4ce7cfbb8957a6a296d0500eb013b185687c1702e3b01f995efc5b5f343ffd109292cca074407268205aabc7c6e3ac1f594d8bb74f89eadb33e5655109483631dde8e040b95d948e5dccc2129160917412077cca9f020fa17939601d78f37e61c5f89ca7fc6df259f56b6ffae8d8c26453259eab6f8bcd433e0114f90bceb503863e2d2a32b74127d9ec5bf5d9fdda2674e6f338880e7b4a5a3756fdc739cf5a8352c2bfd611174a5856bf5675978545b9f9d3db820a0c45ed81c952a216b86b68fcfda8f1c5e2f203b3e5deba36b067cb7b1a275326016e72abb1bb6d4f24299f45a33aef935f56d1e19a9b9fd913fe924a662ffc36c4dcaa03fff31448ada2e237f5e74b2e28e2915fcb785f8ee9adaa3bfda97cd3b94b0a27b75bfe14817f996a3dc97b4bccaf19d80cffbf28beb37c2b17b8985f2ae6a50eff34c8de33e262b3e9e30e595bcd9bccc0054cb18f0f5707d6611cd701fcaa5cfdcc5c0d40139cdbe23a97d21b2d1e73b09065dd6213c03ee0220c2eb81495f6c6f2565286193eb1211d5f4c13e4a72017deabf5ec77174f830b92f9675ac3925647ea094a94080b833f8308c92eef2766d5f65fd12595bb714835d02ad28f422cd0dd07c166d4e81645b73b116c36ccc0f5a8be068fcc6ac3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1b0aac60dd960d61eac723201397c199"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
